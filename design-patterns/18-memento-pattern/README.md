### 备忘录模式(Memento Pattern)

#### 概念
备忘录模式（Memento Pattern） 提供了一种弥补真实世界缺陷的方法， 让“后悔药”在程序的世界中真实可行， 其定义如下：

在不破坏封装性的前提下， 捕获一个对象的内部状态， 并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。

**Originator 发起人角色**

记录当前时刻的内部状态， 负责定义哪些属于备份范围的状态， 负责创建和恢复备忘录数据。

**Memento 备忘录角色**

负责存储Originator发起人对象的内部状态， 在需要的时候提供发起人需要的内部状态。

**Caretaker 备忘录管理员角色**

对备忘录进行管理、 保存和提供备忘录。

#### 使用场景

* 需要保存和恢复数据的相关状态场景。
* 提供一个可回滚（rollback） 的操作； 比如Word中的CTRL+Z组合键， IE浏览器中的后退按钮， 文件管理器上的backspace键等。
* 需要监控的副本场景中。 例如要监控一个对象的属性， 但是监控又不应该作为系统的主业务来调用， 它只是边缘应用， 即使出现监控不准、 错误报警也影响不大， 因此一般的做法是备份一个主线程中的对象， 然后由分析程序来分析。
* 数据库连接的事务管理就是用的备忘录模式， 想想看， 如果你要实现一个JDBC驱动， 你怎么来实现事务？ 还不是用备忘录模式嘛！

#### 注意事项

**备忘录的生命期**

备忘录创建出来就要在“最近”的代码中使用， 要主动管理它的生命周期， 建立就要使用， 不使用就要立刻删除其引用， 等待垃圾回收器对它的回收处理。

**备忘录的性能**

不要在频繁建立备份的场景中使用备忘录模式（比如一个for循环中） ， 原因有二： 一是控制不了备忘录建立的对象数量； 二是大对象的建立是要消耗资源的， 系统的性能需要考虑。 因此， 如果出现这样的代码， 设计师就应该好好想想怎么修改架构了。

#### 扩展

**clone方式的备忘录**

还记得在第13章中讲的原型模式吗？ 我们可以通过复制的方式产生一个对象的内部状态， 这是一个很好的办法， 发起人角色只要实现Cloneable就成， 比较简单。

详情见leoli.pattern.memento.extend.clone包中的示例

* 优点：程序精简了很多， 而且高层模块的依赖也减少了。
* 缺点：在复杂的场景下它会让你的程序逻辑异常混乱， 出现错误也很难跟踪。 因此Clone方式的备忘录模式适用于较简单的场景。

**多状态的备忘录**

我们以上讲解都是单状态的情况， 在实际的开发中一个对象不可能只有一个状态， 一个JavaBean有多个属性非常常见， 这都是它的状态， 如果照搬我们以上讲解的备忘录模式， 是不是就要写一堆的状态备份、 还原语句？ 这不是一个好办法， 这种类似的非智力劳动越多， 犯错误的几率越大， 那我们有什么办法来处理多个状态的备份问题呢？

下面我们来讲解一个对象全状态备份方案， 它有多种处理方式， 比如使用Clone的方式就可以解决， 使用数据技术也可以解决（DTO回写到临时表中） 等， 我们要讲的方案就对备忘录模式继续扩展一下， 实现一个JavaBean对象的所有状态的备份和还原。

如leoli.pattern.memento.extend.morestate包下代码所示。

通过这种方式的改造， 不管有多少状态都没有问题， 直接把原有的对象所有属性都备份了一遍， 想恢复当时的点数据？ 那太容易了！

**注意** 如果要设计一个在运行期决定备份状态的框架， 则建议采用AOP框架来实现， 避免采用动态代理无谓地增加程序逻辑复杂性。

**多备份的备忘录**

不知道你有没有做过系统级别的维护？ 比如Backup Administrator（备份管理员） ， 每天负责查看系统的备份情况， 所有的备份都是由自动化脚本产生的。 有一天， 突然有一个重要的系统说我数据库有点问题， 请把上一个月末的数据拉出来恢复， 那怎么办？ 对备份管理员来说， 这很好办， 直接根据时间戳找到这个备份， 还原回去就成了， 但是对于我们刚刚学习的备忘录模式却行不通， 为什么呢？ 它对于一个确定的发起人， 永远只有一份备份， 在这种情况下， 单一的备份就不能满足要求了， 我们需要设计一套多备份的架构。

我们先来说一个名词， 检查点（Check Point） ， 也就是你在备份的时候做的戳记， 系统级的备份一般是时间戳， 那我们程序的检查点该怎么设计呢？ 一般是一个有意义的字符串。

我们只要把通用代码中的Caretaker管理员稍做修改就可以了， 如代码清单所示：
```java
public class Caretaker {
    //容纳备忘录的容器
    private HashMap<String,Memento> memMap = new HashMap<String,Memento>();

    public Memento getMemento(String idx) {
        return memMap.get(idx);
    }
    public void setMemento(String idx,Memento memento) {
        this.memMap.put(idx, memento);
    }
}
```
把容纳备忘录的容器修改为Map类型就可以了， 场景类也稍做改动， 如代码清单所示。
```java
    //定义出发起人
    Originator originator = new Originator();
    //定义出备忘录管理员
    Caretaker caretaker = new Caretaker();

    //创建两个备忘录
    caretaker.setMemento("001",originator.createMemento());
    caretaker.setMemento("002",originator.createMemento());

    //恢复一个指定标记的备忘录
    originator.restoreMemento(caretaker.getMemento("001"));
```
**注意** 内存溢出问题， 该备份一旦产生就装入内存， 没有任何销毁的意向， 这是非常危险的。 因此， 在系统设计时， 要严格限定备忘录的创建， 建议增加Map的上限， 否则系统很容易产生内存溢出情况。