### 装饰模式(Decorator Pattern)

#### 概念
动态地给一个对象添加一些额外的职责。

#### 优点
* 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须直到Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。
* 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。
* 装饰模式可以动态地扩展一个实现类的功能，这个不需要多说，装饰模式的定义就是如此。

#### 缺点
对于装饰模式记住一点就够了：多层的装饰是比较复杂的。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧。因此，尽量减少装饰类的数量，以便降低系统的复杂度。

#### 使用场景
* 需要扩展一个类的功能，或给一个类增加附加功能。
* 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
* 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。

#### 最佳实践
1、装饰模式是对继承的有力补充。也就是说，装饰模式可以替代继承，解决我们类膨胀的问题。同时，你还要知道继承是静态地给类增加功能，而装饰模式则是动态地增加功能。
2、扩展性非常好。在一个项目中，你会有非常多的因素考虑不到，特别是业务的变更，不时地冒出一个需求，尤其是提出一个令项目大量延迟的需求时，那种心情是相当的难受！装饰模式可以给我们很好的帮助，通过装饰模式重新封装一个类，而不是通过继承来完成。这样对原有程序没有变更，通过扩展很好地完成了这次变更。