### 状态模式(Stete Pattern)

#### 概念

当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。

状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。

**State 抽象状态角色**

接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。
**ConcreteState 具体状态角色**

每一个具体状态必须完成两个职责： 本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。

**Context 环境角色**

定义客户端需要的接口，并且负责具体状态的切换。
环境角色有两个不成文的约束：
    
    * 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。
    * 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。

#### 优点

**结构清晰**

避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性,提高系统的可维护性。

**遵循设计原则**

很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。

**封装性非常好**

这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。

#### 缺点

只有一个缺点，子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。

#### 使用场景

**行为随状态改变而改变的场景**

这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。

**条件、分支判断语句的替代者**

在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。

#### 注意事项

状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。

#### 最佳实践

再提一个问题，状态间的自由切换，那会有很多种呀，你要挨个去牢记一遍吗？比如上面那个电梯的例子，我要一个正常的电梯运行逻辑，规则是开门->关门->运行->停止；还要一个紧急状态（如火灾） 下的运行逻辑，关门->停止，紧急状态时，电梯当然不能用了；再要一个维修状态下的运行逻辑，这个状态任何情况都可以，开着门电梯运行？可以！ 门来回开关？可以！ 永久停止不动？可以！ 那这怎么实现呢？需要我们把已经有的几种状态按照一定的顺序再重新组装一下，那这个是什么模式？什么模式？大声点！ 建造者模式！ 对，建造模式+状态模式会起到非常好的封装作用。

更进一步，应该有部分读者做过工作流开发，如果不是土制框架，那么就应该有个状态机管理（即使是土制框架也应该有），如一个Activity（节点） 有初始化状态（InitializedState）、挂起状态（Suspended State）、完成状态（Completed State） 等，流程实例也有这么多状态，那这些状态怎么管理呢？通过状态机（State Machine） 来管理，那状态机是个什么东西呢？就是我们上面提到的Context类的升级变态BOSS！