### 享元模式(Flyweight Pattern)

#### 概念

享元模式是池技术的重要实现方式，其定义如下： 

使用共享对象可有效地支持大量的细粒度的对象。

要求细粒度对象，那么不可避免地使得对象数量多且性质相近，那我们就将这些对象的信息分为两个部分： 内部状态（intrinsic） 与外部状态（extrinsic）。

**内部状态**

内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变，如我们例子中的id、postAddress等，它们可以作为一个对象的动态附加信息，不必直接储存在具体某个对象中，属于可以共享的部分。

**外部状态**

外部状态是对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态，如我们例子中的考试科目+考试地点复合字符串，它是一批对象的统一标识，是唯一的一个索引值。

#### 角色

**Flyweight 抽象享元角色**

它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。

**ConcreteFlyweight 具体享元角色**

具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。

**unsharedConcreteFlyweight 不可共享的享元角色**

不存在外部状态或者安全要求（如线程安全） 不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。

**FlyweightFactory 享元工厂**

职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。

#### 优点和缺点

享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。

#### 使用场景

* 系统中存在大量的相似对象。
* 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。
* 需要缓冲池的场景。

#### 扩展

**线程安全问题**

若设置的对象过少，外部状态和内部状态划分不合理，多个线程共同修改一个对象时，有线程安全隐患。要在需要的地方考虑一下线程安全。我们在使用享元模式时，对象池中的享元对象尽量多，多到足够满足业务为止。

**性能平衡**

使用对象多为外部状态时，性能比用Java基本类型差很多。

各位，想想看，使用自己编写的类作为外部状态，必须覆写equals方法和hashCode方法，而且执行效率还比较低，这种吃力不讨好的事情最好别做，外部状态最好以Java的基本类型作为标志，如String、int等，可以大幅地提升效率。


#### 注意事项

尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题。在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。我们在一个银行的分析型项目中就采用JRuby进行运算处理，避免使用解释器模式的四则运算，效率和性能各方面表现良好。

#### 最佳实践

Flyweight是拳击比赛中的特用名词，意思是“特轻量级”，指的是51公斤级比赛，用到设计模式中是指我们的类要轻量级，粒度要小，这才是它要表达的意思。粒度小了，带来的问题就是对象太多，那就用共享技术来解决。

享元模式在Java API中也是随处可见，如这样的程序就是一个很好的例子，如代码清单所示。
```java
public class Test {
    public static void main(String[] args) {
        String str1 = "和谐";
        String str2 = "社会";
        String str3 = "和谐社会";
        String str4;
        str4 = str1 + str2;
        System.out.println(str3 == str4);
        str4 = (str1 + str2).intern();
        System.out.println(str3 == str4);
    }
}
```
看看Java的帮助文件中String类的intern方法。如果是String的对象池中有该类型的值，则直接返回对象池中的对象，那当然相等了。

需要说明一下的是，虽然可以使用享元模式可以实现对象池，但是这两者还是有比较大的差异，对象池着重在对象的复用上，池中的每个对象是可替换的，从同一个池中获得A对象和B对象对客户端来说是完全相同的，它主要解决复用，而享元模式在主要解决的对象的共享问题，如何建立多个可共享的细粒度对象则是其关注的重点。