### 代理模式

#### 概念
为其他对象提供一个代理以控制对这个对象的访问。

#### 优点
* 职责清晰。真是的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是变成简洁清晰。  
* 高扩展性。具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱如来佛的手掌（接口），那我们的代理类完全就可以在不做任何修改的情况下使用。
* 智能化。

#### 普通代理
普通代理就是我们要知道代理的存在，然后才能访问。

在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色想怎么修改就怎么修改，对高层次的模块没有任何的影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求较高的场合。当然，在实际项目中，一般都是通过约定来禁止
new一个真实的角色，这也是一个非常好的方案。

注意：普通代理模式的约束问题，尽量通过团队内的编程规范来约束，因为每一个主题类是可被重用的和可维护的，使用技术约束的方式对系统维护是一种非常不利的因素。

#### 强制代理
强制代理则是调用者直接调用真实角色，而不用关心代理是否存在。

强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。 

#### 动态代理
 动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。相对来说，自己写代理类的方法就是静态代理。现在有个非常流行的名称叫做面向切面变成，也就是AOP（Aspect Oriented Programming），其核心就是采用了动态代理机制。
 
 注意：要实现动态代理的首要条件是：被代理类必须实现一个接口。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。
 
#### 使用场景
一个类可以实现多个接口，完成不同任务的整合。也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务，而且代理的目的是在目标对象方法的基础上作增强，这种增强的本质通常就是对目标对象进行拦截和过滤。例如游戏代理是需要收费的，升一级需要5元钱，这个计算功能就是代理类的个性，它应该在代理的接口中定义。

#### 最佳实践
代理模式应用得非常广泛，大到一个系统框架、企业平台，小到代码片段、事务处理，稍不留意就用到代理模式。可能该模式是大家接触最多的模式，而且有了AOP写代理就更加简单了，有类似Spring AOP和AspectJ这样非常优秀的工具，拿来主义即可！不过，大家可以看看源代码，特别是调试时，只要看到类似$Proxy0这样的接口，你就应该知道这是一个动态代理了。

注意：学习AOP框架时，弄清楚几个名词就成：切面（Aspect）、切入点（JoinPoint）、通知（Advice）、织入（Weave）就足够了，理解了这几个名词，应用时就可以游刃有余了。